package main

import (
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"strings"
)

const prefix = `// Code generated by STORED DO NOT EDIT.`
const postfix = `// End of STORED generated code`

// Generator used collected info to generate stored code
type Generator struct {
	file *File
	pos  int
	src  string
}

func (g *Generator) setPosition(file *File, pos int) {
	g.file = file
	g.pos = pos
}

func (g *Generator) cutOldCode(code string) (string, error) {
	for {
		cutStart := strings.Index(code, prefix)
		if cutStart == -1 {
			break
		}

		cutEnd := strings.Index(code, postfix)
		if cutEnd == -1 {
			return code, errors.New("old code closing tag «" + postfix + "» not found")
		}
		cutEnd += len(postfix)
		if len(code) > cutEnd {
			cutEnd++
		}
		code = code[:cutStart] + code[cutEnd:]
		if cutStart < g.pos {
			g.pos -= cutEnd - cutStart
			if cutEnd > g.pos {
				return code, errors.New("//go:generate tag in inside already generated code block, please place //go:generate at the top of file")
			}
		}

	}
	return code, nil
}

func (g *Generator) write() {
	if g.file == nil {
		fmt.Printf("no generate tag found, please put this tag in your code //go:generate $GOPATH/bin/stored")
		return
	}
	codeBytes, err := ioutil.ReadFile(g.file.name)
	if err != nil {
		fmt.Printf("could not read file «%s»: %v", g.file.name, err)
		return
	}
	code := string(codeBytes)
	code, err = g.cutOldCode(code)
	if err != nil {
		fmt.Println("new code ERRR", err)
		fmt.Printf("%s", err)
		return
	}

	code = code[0:g.pos] + g.src + code[g.pos:]
	//lines := bytes.Split(b, []byte{'\n'})

	err = ioutil.WriteFile(g.file.name, []byte(code), 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func (g *Generator) line(line string) {
	g.src += "\n" + line
}

func (g *Generator) block(line string) {
	g.src += "\n" + line + "\n"
}

// Generate triggers code generation
func (g *Generator) Generate() {
	g.line(prefix)
	/*g.line(`func test() {
		fmt.Println("wow")
	}`)*/
	g.line(postfix)

	//g.write()
}
